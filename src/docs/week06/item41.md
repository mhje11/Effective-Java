# 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라

### 마커 인터페이스와 마커 애너테이션
```java
public interface Serializable {} // 마커 인터페이스

public class User implements Serializable {} // 마커 인터페이스 구현
```

- 마커인터페이스는 특정 타입을 매개변수로 받기 가능
```java
public void save(Serializable obj) { 
    // 직렬화 로직 수행
}
```

```java
public @interface Serializable {} // 마커 애너테이션

public class User {
    @Serializable // ❌ 애너테이션을 붙여도 타입 체크 불가능
}
```

```java
public void save(Serializable obj) { } // ❌ 컴파일 오류 → 애너테이션은 타입이 아님
```

### 마커 인터페이스가 마커 애너테이션 보다 나은점
- 1. 마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 쓸 수 있음 하지만 마커 애너테이션은 아님
- 2. 적용 대상을 더 정밀하게 지정할 수 있음, 마커 애너테이션은 적용 대상(@Target)을 Element.Type 으로 선언한 애너테이션은 모든 타입에 달 수 있음
     부착 할 수 있는 타입을 더 세밀하게 제한히지 못한다는 의미 
     특정 인터페이스를 구현한 클래스에만 적용하고 싶은 마커가 있다 가정해보면
     마커를 인터페이스로 정의했다면 그냥 마킹하고 싶은 클래스에 해당 인터페이스를 구현하면 됨 그러면 마킹된 타입은 자동으로 그 인터페이스의 하위 타입임이 보장됨

- 3. 마커 애너테이션이 마커 인터페이스보다 나은 점으로는 거대한 애너테이션 시스템의 지원을 받는다는 점

### 마커 애너테이션, 마커 인터페이스를 써야하는 경우

#### 마커 애너테이션 사용하는 경우
- 클래스와 인터페이스 외의 프로그램 요소(모듈, 패키지, 필드, 지역변수 등)에 마킹해야 할 때 애너테이션을 쓸 수 밖에 없음.
  - 왜? 클래스와 인터페이스만이 인터페이스를 구현하거나 확장할 수 있기 때문
- 추가로 애너테이션을 활발히 활용하는 프레임워크에서 사용하려는 마커라면 마커 애너테이션을 사용 하는 편이 좋음

#### 마커 인터페이스를 사용하는 경우 
- 마킹이 된 객체를 매개변수로 받는 메서드를 작성할 일이 있을 경우
- 새로 추가하는 메서드 없이 단지 타입 정의가 목적일 경우
     

### 마커 인터페이스 vs 마커 애너테이션
| 기준 | 마커 인터페이스 | 마커 애너테이션 |
|------|--------------|--------------|
| **컴파일 타임 타입 체크** | ✅ O | ❌ X |
| **instanceof 사용 가능** | ✅ O | ❌ X |
| **특정 계층(타입)만 제한 가능** | ✅ O | ❌ X |
| **클래스 이외의 요소(메서드, 필드, 패키지 등) 적용** | ❌ X | ✅ O |
| **리플렉션 기반 프레임워크 사용** | ❌ X | ✅ O |
